config {
  type: "table",
  tags: [dataform.projectConfig.vars.GA4_DATASET,"base_events","prod"],
  description: "Output events table: unnested, cleaned, clustered data with several fixes",
  database: dataform.projectConfig.vars.OUTPUT_PROJECT
  }

  -- ==============================
  --        JS BLOCK
  -- ==============================

js {
  // Require your helper functions.
  const helperFunctions = require("includes/helper_functions");
  //const default_config = helperFunctions.getConfig();

  // Explicitly require the merged config from your config file.
  const { mergedConfig } = require("includes/config");
  const config = {
    ...mergedConfig
  };
   helperFunctions.checkColumnNames(config);
}

  -- ==============================
  --        PRE-OPERATIONS
  -- ==============================
 pre_operations {
  declare start_date string default '20240716';
  declare end_date string default '20241009';
 }
 
  -- ==============================
  --        QUERY BLOCK
  -- ==============================
---========================== Step 1 ================================
with 

step1 as (

  select
    -- first chunk: the basics
    event_timestamp,
    event_name,
    parse_date('%Y%m%d', event_date) as event_date, -- partition column
    date_diff(current_date(), cast(event_date as date format 'YYYYMMDD'), day) > ${config.DATA_IS_FINAL_DAYS} as is_final, -- used for incrementality
    stream_id,
    platform,
    struct(
      -- timestamps
      event_timestamp,
      timestamp_micros(event_timestamp) as event_timestamp_utc,
      user_first_touch_timestamp as user_first_touch_timestamp,
      timestamp_micros(user_first_touch_timestamp) as user_first_touch_timestamp_utc  
    ) as time,
    
    -- user info
    user_pseudo_id,
    user_id,
    is_active_user,

    -- event info
    batch_event_index,
    batch_ordering_id,
    batch_page_id,

    -- now the structs - we will need to explicitly name ALL fields herein, as to not break incremental builds when Google adds a column in a struct
    -- privacy info
    struct(
      privacy_info.analytics_storage as analytics_storage,
      privacy_info.ads_storage as ads_storage
    ) as privacy_info,
    
    struct(
      collected_traffic_source.manual_campaign_id,
      collected_traffic_source.manual_campaign_name,
      collected_traffic_source.manual_source,
      collected_traffic_source.manual_medium,
      collected_traffic_source.manual_term,
      collected_traffic_source.manual_content,
      collected_traffic_source.manual_source_platform,
      collected_traffic_source.manual_creative_format,
      collected_traffic_source.manual_marketing_tactic,
      collected_traffic_source.gclid,
      collected_traffic_source.dclid,
      collected_traffic_source.srsltid
    ) as collected_traffic_source, -- as is. This will be fixed in the next step

    struct(
      struct(
        session_traffic_source_last_click.manual_campaign.campaign_id,
        session_traffic_source_last_click.manual_campaign.campaign_name,
        session_traffic_source_last_click.manual_campaign.source,
        session_traffic_source_last_click.manual_campaign.medium,
        session_traffic_source_last_click.manual_campaign.term,
        session_traffic_source_last_click.manual_campaign.content,
        session_traffic_source_last_click.manual_campaign.source_platform,
        session_traffic_source_last_click.manual_campaign.creative_format,
        session_traffic_source_last_click.manual_campaign.marketing_tactic
      ) as manual_campaign,
      struct(
        session_traffic_source_last_click.google_ads_campaign.customer_id,
        session_traffic_source_last_click.google_ads_campaign.account_name,
        session_traffic_source_last_click.google_ads_campaign.campaign_id,
        session_traffic_source_last_click.google_ads_campaign.campaign_name,
        session_traffic_source_last_click.google_ads_campaign.ad_group_id,
        session_traffic_source_last_click.google_ads_campaign.ad_group_name       
      ) as google_ads_campaign,
      struct(
        session_traffic_source_last_click.cross_channel_campaign.campaign_name,
        session_traffic_source_last_click.cross_channel_campaign.campaign_id,
        session_traffic_source_last_click.cross_channel_campaign.source,
        session_traffic_source_last_click.cross_channel_campaign.medium,
        session_traffic_source_last_click.cross_channel_campaign.source_platform,
        session_traffic_source_last_click.cross_channel_campaign.default_channel_group,
        session_traffic_source_last_click.cross_channel_campaign.primary_channel_group
      ) as cross_channel_campaign,
      struct(
        session_traffic_source_last_click.sa360_campaign.campaign_id,
        session_traffic_source_last_click.sa360_campaign.campaign_name,
        session_traffic_source_last_click.sa360_campaign.source,
        session_traffic_source_last_click.sa360_campaign.medium,
        session_traffic_source_last_click.sa360_campaign.ad_group_id,
        session_traffic_source_last_click.sa360_campaign.ad_group_name,
        session_traffic_source_last_click.sa360_campaign.creative_format,
        session_traffic_source_last_click.sa360_campaign.engine_account_name,
        session_traffic_source_last_click.sa360_campaign.engine_account_type,
        session_traffic_source_last_click.sa360_campaign.manager_account_name
      ) as sa360_campaign,
      struct(
        session_traffic_source_last_click.cm360_campaign.campaign_id,
        session_traffic_source_last_click.cm360_campaign.campaign_name,
        session_traffic_source_last_click.cm360_campaign.source,
        session_traffic_source_last_click.cm360_campaign.medium,
        session_traffic_source_last_click.cm360_campaign.account_id,
        session_traffic_source_last_click.cm360_campaign.account_name,
        session_traffic_source_last_click.cm360_campaign.advertiser_id,
        session_traffic_source_last_click.cm360_campaign.advertiser_name,
        session_traffic_source_last_click.cm360_campaign.creative_id,
        session_traffic_source_last_click.cm360_campaign.creative_format,
        session_traffic_source_last_click.cm360_campaign.creative_name,
        session_traffic_source_last_click.cm360_campaign.creative_type,
        session_traffic_source_last_click.cm360_campaign.creative_type_id,
        session_traffic_source_last_click.cm360_campaign.creative_version,
        session_traffic_source_last_click.cm360_campaign.placement_id,
        session_traffic_source_last_click.cm360_campaign.placement_cost_structure,
        session_traffic_source_last_click.cm360_campaign.placement_name,
        session_traffic_source_last_click.cm360_campaign.rendering_id,
        session_traffic_source_last_click.cm360_campaign.site_id,
        session_traffic_source_last_click.cm360_campaign.site_name
      ) as cm360_campaign,
      struct(
        session_traffic_source_last_click.dv360_campaign.campaign_id,
        session_traffic_source_last_click.dv360_campaign.campaign_name,
        session_traffic_source_last_click.dv360_campaign.source,
        session_traffic_source_last_click.dv360_campaign.medium,
        session_traffic_source_last_click.dv360_campaign.advertiser_id,
        session_traffic_source_last_click.dv360_campaign.advertiser_name,
        session_traffic_source_last_click.dv360_campaign.creative_id,
        session_traffic_source_last_click.dv360_campaign.creative_format,
        session_traffic_source_last_click.dv360_campaign.creative_name,
        session_traffic_source_last_click.dv360_campaign.exchange_id,
        session_traffic_source_last_click.dv360_campaign.exchange_name,
        session_traffic_source_last_click.dv360_campaign.insertion_order_id,
        session_traffic_source_last_click.dv360_campaign.insertion_order_name,
        session_traffic_source_last_click.dv360_campaign.line_item_id,
        session_traffic_source_last_click.dv360_campaign.line_item_name,
        session_traffic_source_last_click.dv360_campaign.partner_id,
        session_traffic_source_last_click.dv360_campaign.partner_name
      ) as dv360_campaign
    ) 
    -- ELSE NULL END 
    as session_traffic_source_last_click,

    struct(
        publisher.ad_format,
        publisher.ad_revenue_in_usd,
        publisher.ad_source_name,
        publisher.ad_unit_id
    ) as publisher,
    
    --ecommerce, -- for now. Will be repacked and cleaned below in step 2
    struct(
        ecommerce.total_item_quantity,
        if(is_nan(ecommerce.purchase_revenue_in_usd), 0,ecommerce.purchase_revenue_in_usd) as purchase_revenue_in_usd,
        if(is_nan(ecommerce.purchase_revenue), 0,ecommerce.purchase_revenue) as purchase_revenue,
        if(is_nan(ecommerce.refund_value_in_usd), 0,ecommerce.refund_value_in_usd) as refund_value_in_usd,
        if(is_nan(ecommerce.refund_value), 0,ecommerce.refund_value) as refund_value,
        if(is_nan(ecommerce.shipping_value_in_usd), 0,ecommerce.shipping_value_in_usd) as shipping_value_in_usd,
        if(is_nan(ecommerce.shipping_value), 0,ecommerce.shipping_value) as shipping_value,
        if(is_nan(ecommerce.tax_value_in_usd), 0,ecommerce.tax_value_in_usd) as tax_value_in_usd,
        if(is_nan(ecommerce.tax_value), 0,ecommerce.tax_value) as tax_value,
        ecommerce.unique_items,
        if(ecommerce.transaction_id = '(not set)', null, ecommerce.transaction_id) as transaction_id
    ) as ecommerce,

    struct(
        user_ltv.revenue,
        user_ltv.currency
    ) as user_ltv,

    struct(
      device.category,
      device.mobile_brand_name,
      device.mobile_model_name,
      device.mobile_marketing_name,
      device.mobile_os_hardware_model,
      device.operating_system,
      device.operating_system_version,
      device.vendor_id,
      device.advertising_id,
      device.language,
      device.is_limited_ad_tracking,
      device.time_zone_offset_seconds,
      struct(
        device.web_info.browser,
        device.web_info.browser_version,
        device.web_info.hostname
      ) as web_info
    ) as device,

    struct(
        app_info.id,
        app_info.version,
        app_info.install_store,
        app_info.firebase_app_id,
        app_info.install_source
    ) as app_info,

    struct(
        geo.continent,
        geo.country,
        geo.region,
        geo.city,
        geo.sub_continent,
        geo.metro
    ) as geo,

    struct(
        traffic_source.name as campaign_name,
        traffic_source.source,
        traffic_source.medium
    ) as first_user_traffic_source,

    struct(
      batch_event_index,
      batch_ordering_id,
      batch_page_id
    ) as batch,

    -- grab all core event parameters
    ${helper_functions.generateStructSQL(helper_functions.generateParamsSQL(config.CORE_PARAMS_ARRAY))} as event_params,

    -- and the custom ones
    ${when(
      config.CUSTOM_EVENT_PARAMS_ARRAY.length > 0,
        `${helper_functions.generateStructSQL(helper_functions.generateParamsSQL(config.CUSTOM_EVENT_PARAMS_ARRAY))} as event_params_custom,`
      )} 

    -- add user_properties
    ${when(
      config.CUSTOM_USER_PROPERTIES_ARRAY.length > 0,      
        `${helper_functions.generateStructSQL(helper_functions.generateParamsSQL(config.CUSTOM_USER_PROPERTIES_ARRAY,'user_properties'))} as user_properties,`
      )}

 from ${ref("events_*")}
    where

    _table_suffix between start_date and end_date
   
    -- filters go here
    -- intraday filter: exclude
    and contains_substr(_table_suffix, 'intraday') is false
    -- fresh filter: exclude
    and contains_substr(_table_suffix, 'fresh') is false

    -- filters from config:
    -- discard unwanted events
    and ${helper_functions.generateFilterTypeFromListSQL("exclude", "event_name", config.EVENTS_TO_EXCLUDE)}
    -- discard unwanted hostnames
    and ${helper_functions.generateFilterTypeFromListSQL("exclude", "device.web_info.hostname", config.HOSTNAME_EXCLUDE)}
    -- only include wanted hostnames
    and ${helper_functions.generateFilterTypeFromListSQL("include", "device.web_info.hostname", config.HOSTNAME_INCLUDE_ONLY)}

),

---========================== Step 2 ================================
 -- create event_id & session_id, Add property_id
step2 as (
  select
     -- create event ID
    farm_fingerprint(
      event_name ||
      time.event_timestamp ||
      coalesce(user_pseudo_id, 'no') ||
      coalesce(event_params.ga_session_id, 0) ||
      coalesce(batch.batch_page_id, 0) ||
      coalesce(batch.batch_ordering_id,0) ||
      coalesce(batch.batch_event_index,0) ||
      coalesce(event_params.engagement_time_msec, 0)
    ) as event_id,
    '${dataform.projectConfig.vars.GA4_DATASET}' as property_id,
     ${helper_channel_groupings.getdefaultChannelGroupingSQL("session_traffic_source_last_click")} as default_channel_group,
     concat(
      user_pseudo_id , CAST(event_params.ga_session_id AS STRING)
     ) as session_id,
     
     *
  from step1
),
---========================== Step 3 ================================
add_meta_info as (
  select     
    -- try to guess if this is a MP hit
    if(device.language is null and device.operating_system is null and device.category = 'desktop',
       true,
       false
    ) as is_measurement_protocol_hit,

    -- all page information in a page struct
    struct (
        device.web_info.hostname as hostname,
       regexp_extract(event_params.page_location, r'^(?:(?:[^:\/?#]+):)?(?:\/\/(?:[^\/?#]*))?([^?#]*)(?:\?(?:[^#]*))?(?:#(?:.*))?') as path, ---Change this to reference getPagePath helper function
      -- ${helper_functions.getPagePathFromFullUrl("event_params.page_location","device.web_info.hostname")} as page_path,
        event_params.page_location ,     -- this is temporary until we fix error in the above line AZ
       event_params.page_referrer as referrer,
       event_params.page_title as title
      ) as page,
    *
   except(
        time
      ),
    (
        select as struct
          time.*,
          datetime(time.event_timestamp_utc, '${dataform.projectConfig.vars.LOCAL_TIMEZONE}') as timestamp_local,
          date(datetime(time.event_timestamp_utc, '${dataform.projectConfig.vars.LOCAL_TIMEZONE}')) as date_local
    ) time,
  from step2
),

---========================== Step 4 ================================
add_row_numbers as (
  select
    *,
    struct(
    -- calculate hit numbers per session (now is the time)
    if(user_pseudo_id is not null and event_params.ga_session_id is not null,
        row_number() over (
          partition by user_pseudo_id, event_params.ga_session_id
          order by time.event_timestamp asc
        ),
        null
     ) as hit_number,

    -- and page number
    if(user_pseudo_id is not null and event_params.ga_session_id is not null and batch.batch_page_id is not null,
        dense_rank() over (
          partition by user_pseudo_id, event_params.ga_session_id
          order by batch.batch_page_id asc
        ),
        null
     ) as page_number
    ) as session_info

  from add_meta_info
)


---========================== Final Step ================================

select
  current_timestamp() as _run_timestamp, -- indicates when the row was last run
  *
from add_row_numbers
where true



